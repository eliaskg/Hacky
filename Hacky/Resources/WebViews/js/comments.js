function parseComments(jsonString) {
  var container = $('#comments');
  
  try {
    var comments = JSON.parse(jsonString);
  }
  catch(error) {
    container.html('<div class="error">' + error + '</div>');
    return;
  }
  
  container.html('');
  
  document.body.scrollTop = 0;
  
  for (var i = 0; i < comments.length; i++) {
    var comment = comments[i];
    var element = $('<div class="commentContainer margin-' + comment.margin + '">' +
                      '<div class="meta">' +
                        '<span class="username">' +
                          comment.user +
                          '<span class="minimizer">-</span>' +
                        '</span>' +
                        '<span class="createdAt">' +
                          comment.created +
                        '</span>' +
                      '</div>' +
                      comment.content +
                    '</div>');
    
    container.append(element);
  }
}

function didClickMinimizer(event) {
  var button = $(event.target);
  var commentContainer = button.parents('.commentContainer');

  if (button.html() === '-') {
    commentContainer.find('.meta').addClass('hidden');
    commentContainer.find('.comment').hide();
    minimizeNextComments(commentContainer, null);

    button.html('+');
  }
  else if (button.html() === '+') {
    commentContainer.find('.meta').removeClass('hidden');
    commentContainer.find('.comment').show();
    maximizeNextComments(commentContainer, null);

    button.html('-');
  }
}

function minimizeNextComments(startComment, initialMargin) {
  var startMargin = +startComment.attr('class').split('-')[1];

  if (initialMargin == null)
    initialMargin = startMargin;

  var nextComment = startComment.next();

  if (!nextComment.length)
    return;

  var nextMargin = +nextComment.attr('class').split('-')[1];

  if (nextMargin > initialMargin) {
    nextComment.hide();
    minimizeNextComments(nextComment, initialMargin);
  }
}

function maximizeNextComments(startComment, initialMargin) {
  var startMargin = +startComment.attr('class').split('-')[1];

  if (initialMargin == null)
    initialMargin = startMargin;

  var nextComment = startComment.next();

  if (!nextComment.length)
    return;

  var nextMargin  = +nextComment.attr('class').split('-')[1];

  if (nextMargin > initialMargin) {
    nextComment.show();
    maximizeNextComments(nextComment, initialMargin);
  }
}

$(document.body).ready(function() {

  var test = 0;
                       false && parseComments('[{"id":"5337179","content":"<span class=\\"comment\\"><font color=\\"#000000\\">And with this one of the huge flaws of OAuth comes to play. OAuth just doesn\'t work with locally installed applications as it\'s impossible to hide anything there, but OAuth strongly relies on the client having some secret knowledge (the client token).<p>As long as all clients are equal when using the API, this might go well (minus some malicious clients), but once some clients start to be more equal than others - even more so as the service starts to get to be real jerks - then the whole system will fall down.<\\/p><p>What we see here is twitter\'s secrets leaking out (though remember: That\'s more or less public data as it\'s technically <i>impossible<\\/i> to hide that info - the server has to know) due to them being jerks giving their client preferential access.<\\/p><p>What does this mean? For now, probably not much as I can imagine the bigger third-party-clients want to behave.<\\/p><p>It might however make Twitter reconsider their policies.<\\/p><p>If not, this is the beginning of a long cat and mouse game of twitter updating their keys and using heuristics to recognize their own client followed by twitter clients providing a way to change the client secret[1].<\\/p><p>Though one thing is clear: Twitter will lose this game as the client secret has to be presented to the server.<\\/p><p>Using SSL and certificate pinning, they can protect the secret from network monitors, but then the secret can still be extracted from the client, at which point, they might encrypt it in the client, at which point the attackers will disassemble the client to still extract the key.<\\/p><p>It remains to be seen how far twitter is willing to go playing that game.<\\/p><p>[1] even if the keys don\'t leak out, as long as twitter allows their users to create API clients, an editable client secret is a way for <i>any<\\/i> twitter client to remain fully usable<\\/p><\\/font><\\/span>","created":"2 hours ago","margin":"0","user":"pilif"},{"id":"5337186","content":"<span class=\\"comment\\"><font color=\\"#000000\\">It\'s not really fair to call this an OAuth flaw, since it\'s just another instance of the \'trusted client\' problem in security.<p>Essentially it\'s impossible to differentiate Twitter\'s own client on an untrusted platform since it will always be possible for \'malicious\' client to behave exactly like Twitter\'s own client.<\\/p><\\/font><\\/span>","created":"2 hours ago","margin":"40","user":"mtrimpe"},{"id":"5337531","content":"<span class=\\"comment\\"><font color=\\"#000000\\">IMHO OAuth doesn\'t work for desktop applications because all the aspects where it tries to provide more security than traditional username\\/password authentication are easily circumvented on the desktop.<p>As such OAuth on the desktop IMHO is not much more than snake oil and does nothing aside of increasing the complexity for the implementer while providing next to zero additional security.<\\/p><p>First is client authentication: OAuth tries to authenticate clients as well as users. On a desktop it\'s not possible to authenticate clients because whatever they do, the information can be extracted and simulated by a malicious client.<\\/p><p>The other thing is that by now many desktop OAuth clients embed a webview for the authentication handshake. There is no way for the user to be sure that they are typing their credentials into the site they think they are. There is no browser chrome, there is usually no URL bar and even if there was, there is zero trust that the URL is actually showing the correct URL.<\\/p><p>Worse: How many client apps are actually going through the trouble of checking SSL certificates (or even that SSL is on)?<\\/p><p>Embedding a webview for an OAuth handshake provides (to the user) no additional security compared to just showing a username\\/password dialog.<\\/p><p>The only way how I see this actually work is if the application opens the default browser for the handshake. But of course that will show a big-ass security warning when redirecting back to the local url protocol.<\\/p><p>In consequence this means that the only method by which OAuth on the desktop could provide additional security is the one method that presents a security warning to the user. How ironic.<\\/p><\\/font><\\/span>","created":"29 minutes ago","margin":"80","user":"pilif"},{"id":"5337265","content":"<span class=\\"comment\\"><font color=\\"#000000\\">OAuth has been called flawed by security experts because it\'s filled with trap holes for developers to fall into[1] and former developers who left the project[2].<p>1. <a href=\\"http:\\/\\/homakov.blogspot.jp\\/2013\\/03\\/oauth1-oauth2-oauth.html\\" rel=\\"nofollow\\">http:\\/\\/homakov.blogspot.jp\\/2013\\/03\\/oauth1-oauth2-oauth.html<\\/a><\\/p><p>2. <a href=\\"http:\\/\\/en.wikipedia.org\\/wiki\\/OAuth#Controversy\\" rel=\\"nofollow\\">http:\\/\\/en.wikipedia.org\\/wiki\\/OAuth#Controversy<\\/a><\\/p><\\/font><\\/span>","created":"1 hour ago","margin":"80","user":"qompiler"},{"id":"5337360","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Sure, but that\'s beside the point. OAuth does not attempt to deal with this problem. If you have the secret consumer token, then you <i>are<\\/i> that consumer in the eyes of OAuth.<\\/font><\\/span>","created":"1 hour ago","margin":"120","user":"eli"},{"id":"5337191","content":"<span class=\\"comment\\"><font color=\\"#000000\\">&gt; OAuth just doesn\'t work with locally installed applications<p>That\'s not really true, Twitter just has a broken model where they want to authenticate the <i>application<\\/i> as well as the user...<\\/p><p>The rest of your comment is quite spot on, though. This is going to be a cat and mouse game for Twitter and I\'m not sure they can win.<\\/p><\\/font><\\/span>","created":"2 hours ago","margin":"40","user":"codeka"},{"id":"5337426","content":"<span class=\\"comment\\"><font color=\\"#000000\\">&gt; Twitter just has a broken model where they want to authenticate the application as well as the user...<p>Can you elaborate? As far as I understand how it works, this is the case by design in OAuth.<\\/p><p>(edit: typo)<\\/p><\\/font><\\/span>","created":"58 minutes ago","margin":"80","user":"martius"},{"id":"5337229","content":"<span class=\\"comment\\"><font color=\\"#000000\\">This is a surprise to absolutely no-one. That client keys &amp; secrets were semi-public knowledge was obvious years ago, before I started working on OAuth at a much younger Twitter. The client key and secret is a rough trust metric for clients that are distributed publicly. Twitter can distribute new clients with new more-hidden secrets, and gain a bit more trust, for a while.<p>The place where the client id and secret actually offer real security is in the hosted scenario, where the secret is never distributed outside a trusted environment. Anyone who tells you different is wrong. The same applies to every single copy protection scheme (SSL\\/TLS, HDCP, DVD Region Coding, etc, etc, etc) and barring some mathematical breakthrough, this will always be true.<\\/p><\\/font><\\/span>","created":"2 hours ago","margin":"40","user":"romeda"},{"id":"5337564","content":"<span class=\\"comment\\"><font color=\\"#000000\\">For some reason several of the commenters here are explaining this away as a protocol bug (specifically with OAuth) but the challenge isn\'t at all protocol specific. Rather, it\'s a hardship with all client\\/server apps, specifically in that trusting any client requires additional support from the platform (self-assertion or possession of a secret by the client alone is insufficient) and even then it\'s known hard problem.<p>This has been true of client\\/server apps for a very long time, well predating any particular protocol. I\'d be sincerely interested in any solutions that people come up with that don\'t depend on additional extrinsic platform capabilities.<\\/p><\\/font><\\/span>","created":"21 minutes ago","margin":"0","user":"dewitt"},{"id":"5337230","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Something I\'ve been pointing out about OAuth for <i>ever<\\/i> is that it\'s a method for delegating authorization to agents who wish to act on behalf of the user. When it is the actual user him\\/herself who is acting, there\'s nothing wrong (and a lot of things right) with username\\/password authentication.<\\/font><\\/span>","created":"2 hours ago","margin":"0","user":"zacharyvoase"},{"id":"5337285","content":"<span class=\\"comment\\"><font color=\\"#000000\\">OAuth prevents apps from nabbing passwords, though.<\\/font><\\/span>","created":"1 hour ago","margin":"40","user":"TazeTSchnitzel"},{"id":"5337363","content":"<span class=\\"comment\\"><font color=\\"#000000\\">If the app is displaying its own internal web view for OAuth, it can load any page it wants in there and tell the user it\'s Twitter. It can even fake an address bar with a twitter.com URL if it wants. Then use the common phishing technique of \'oops, you must have entered your password wrong\' (the user didn\'t, but now the phisher has it), followed by a forward to the real site so the user suspects nothing.<p>But this is hypothetical. In reality there is little motivation for apps in an App Store-like environment, which survive on customer goodwill, to want to do this.<\\/p><p>The user\'s security is probably not why Twitter chose OAuth.<\\/p><\\/font><\\/span>","created":"1 hour ago","margin":"80","user":"dmdeller"},{"id":"5337347","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Any token-based system will.<p>OAuth, having solved this problem, then goes on to create many more.<\\/p><\\/font><\\/span>","created":"1 hour ago","margin":"80","user":"yarrel"},{"id":"5337329","content":"<span class=\\"comment\\"><font color=\\"#000000\\">For people who think this is going to cause drive-by Twitter hijacks, remember that Twitter stores the callback URL on their side for this very reason. Any web app impersonating these apps will fail at the callback stage.<\\/font><\\/span>","created":"1 hour ago","margin":"0","user":"Kudos"},{"id":"5337255","content":"<span class=\\"comment\\"><font color=\\"#000000\\">If you ship a binary to a personâ€™s computer and that binary has a secret embedded in it, that secret will eventually be discovered.<p>This has been discussed here before: <a href=\\"http:\\/\\/news.ycombinator.com\\/item?id=4411696\\" rel=\\"nofollow\\">http:\\/\\/news.ycombinator.com\\/item?id=4411696<\\/a><\\/p><\\/font><\\/span>","created":"1 hour ago","margin":"0","user":"mathias"},{"id":"5337116","content":"<span class=\\"comment\\"><font color=\\"#737373\\">uh, this is not good. Why would someone post that under their own github account?<\\/font><\\/span>","created":"2 hours ago","margin":"0","user":"lukeholder"},{"id":"5337133","content":"<span class=\\"comment\\"><font color=\\"#000000\\">It\'s more or less public knowledge. You can find it yourself by running \\"strings\\" on the Twitter app binary. Any attempts on Twitter\'s part to limit the disclosure of these tokens would almost certainly invoke the Streisand Effect.<\\/font><\\/span>","created":"2 hours ago","margin":"40","user":"cmelbye"},{"id":"5337178","content":"<span class=\\"comment\\"><font color=\\"#000000\\">It would be possible to obfuscate a secret by storing it in several parts and combining them at run time. Still very far from secure, but this would require much more effort to extract the secret from the app.<p>Anyone: what is best practice here (Android and\\/or iOS)?<\\/p><p>Edit:<\\/p><p><i>Storing application secrets in Android\'s credential storage<\\/i> [1]. I have no idea how secure this actually is.<\\/p><p><i>Should I obfuscate OAuth consumer secret stored by Android app?<\\/i> [2]<\\/p><p>[1] <a href=\\"http:\\/\\/nelenkov.blogspot.co.uk\\/2012\\/05\\/storing-application-secrets-in-androids.html\\" rel=\\"nofollow\\">http:\\/\\/nelenkov.blogspot.co.uk\\/2012\\/05\\/storing-application-s...<\\/a><\\/p><p>[2] <a href=\\"http:\\/\\/stackoverflow.com\\/questions\\/7121966\\/should-i-obfuscate-oauth-consumer-secret-stored-by-android-app\\" rel=\\"nofollow\\">http:\\/\\/stackoverflow.com\\/questions\\/7121966\\/should-i-obfuscat...<\\/a><\\/p><\\/font><\\/span>","created":"2 hours ago","margin":"80","user":"andyjohnson0"},{"id":"5337631","content":"<span class=\\"comment\\"><font color=\\"#000000\\"><i>&gt; It would be possible to obfuscate a secret by storing it in several parts and combining them at run time.<\\/i><p>Then run `strings\' on virtual memory image of the offending process. Same difference.<\\/p><\\/font><\\/span>","created":"5 minutes ago","margin":"120","user":"dexen"},{"id":"5337188","content":"<span class=\\"comment\\"><font color=\\"#000000\\">For Android, I suppose you could just run a Java bytecode obfuscator before converting the bytecode to Dalvik. There doesn\'t seem to be something comparable for iOS.<p>One simple solution is to set N-1 arrays to random data (hardcoded or generated at compile time) and set the last array to the real secret XOR random array #1 XOR random array #2 XOR ... XOR random array #N-1; this doesn\'t exactly stop a determined attacker, but it does stop \\"strings\\".<\\/p><\\/font><\\/span>","created":"2 hours ago","margin":"120","user":"JoachimSchipper"},{"id":"5337458","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Unless you know the device isn\'t rooted this doesn\'t really achieve very much. On a rooted device an \\"attacker\\" could have replaced the crede tial storage with something that will conveniently store the data unprotected.<p>It is helpful as a way of ensuring random applications don\'t get hold of the data, but not for keeping the data from a determined user.<\\/p><\\/font><\\/span>","created":"51 minutes ago","margin":"120","user":"vidarh"},{"id":"5337183","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Correct me if I\'m wrong here but I believe that then all one would need to do is stick an SSL intercepting proxy (such as <a href=\\"http:\\/\\/mitmproxy.org\\/doc\\/ssl.html\\" rel=\\"nofollow\\">http:\\/\\/mitmproxy.org\\/doc\\/ssl.html<\\/a>) in the middle and get the keys from there.<\\/font><\\/span>","created":"2 hours ago","margin":"120","user":"pandog"},{"id":"5337211","content":"<span class=\\"comment\\"><font color=\\"#000000\\">That depends on how the secret is used by the client to authenticate with the remote service.<p>If the client just sends the secret as part of an authentication request, then a proxy would reveal it. But if some form of challenge\\/response [1] process is used, where the value sent is derived from the secret and an unpredictable challenge sent by the remote service, then as far as I know a proxy wouldn\'t help.<\\/p><p>I don\'t know enough about the details of the Twitter\\/DropBox\\/etc APIs work to know if they use challenge-response.<\\/p><p>[1] <a href=\\"http:\\/\\/en.wikipedia.org\\/wiki\\/Challenge%E2%80%93response_authentication\\" rel=\\"nofollow\\">http:\\/\\/en.wikipedia.org\\/wiki\\/Challenge%E2%80%93response_auth...<\\/a><\\/p><\\/font><\\/span>","created":"2 hours ago","margin":"160","user":"andyjohnson0"},{"id":"5337190","content":"<span class=\\"comment\\"><font color=\\"#000000\\">It\'s at least <i>possible<\\/i> to accept only the keys from your real servers, which would stop this attack.<p>For what happens in the real world, see Georgiev et al.\'s \\"The most dangerous code in the world\\" at <a href=\\"https:\\/\\/crypto.stanford.edu\\/~dabo\\/pubs\\/abstracts\\/ssl-client-bugs.html\\" rel=\\"nofollow\\">https:\\/\\/crypto.stanford.edu\\/~dabo\\/pubs\\/abstracts\\/ssl-client-...<\\/a> (spoiler: I described this paper in our internal knowledgebase as \\"very readable. Promises lots of facepalming and delivers in spades.\\")<\\/p><\\/font><\\/span>","created":"2 hours ago","margin":"160","user":"JoachimSchipper"},{"id":"5337371","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Only if the app uses the phone\'s certificate store, as opposed to a hard-coded one.<\\/font><\\/span>","created":"1 hour ago","margin":"160","user":"lucian1900"},{"id":"5337136","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Couldn\'t another app use these tokens and take advantage of lax api limits ?<\\/font><\\/span>","created":"2 hours ago","margin":"80","user":"lukeholder"},{"id":"5337148","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Yes. And that\'s the point of the disclosure.<\\/font><\\/span>","created":"2 hours ago","margin":"120","user":"pilif"},{"id":"5337181","content":"<span class=\\"comment\\"><font color=\\"#000000\\">I think Apple will simply not permit applications that use these keys and are not official clients in the App Store. Looks like something that is pretty easy to automate.<\\/font><\\/span>","created":"2 hours ago","margin":"120","user":"jasiek"},{"id":"5337199","content":"<span class=\\"comment\\"><font color=\\"#000000\\">I\'m not sure why Apple would play police for Twitter, though.<\\/font><\\/span>","created":"2 hours ago","margin":"160","user":"codeka"},{"id":"5337603","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Isn\'t Twitter integrated into Apple\'s mobile operating system? Such tight partnerships is plenty reason for them to play police for Twitter.<\\/font><\\/span>","created":"11 minutes ago","margin":"200","user":"cryptoz"},{"id":"5337203","content":"<span class=\\"comment\\"><font color=\\"#000000\\">You presume that one would use the keys on iPhone. No reason you couldn\'t run them on a Linux box in AWS...<\\/font><\\/span>","created":"2 hours ago","margin":"160","user":"cbsmith"},{"id":"5337236","content":"<span class=\\"comment\\"><font color=\\"#000000\\">How would Apple know that the app uses these keys? If they run something similar to strings then all you have to do is store the keys in some kind of obfuscated form.<\\/font><\\/span>","created":"2 hours ago","margin":"160","user":"arethuza"},{"id":"5337310","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Right but as soon as the press find out, and they will, that developer account will be banned. Most devs won\'t see it as worth the risk.<\\/font><\\/span>","created":"1 hour ago","margin":"200","user":"interpol_p"},{"id":"5337429","content":"<span class=\\"comment\\"><font color=\\"#000000\\">What responsibility does Apple have to Twitter except the notification center widget?<\\/font><\\/span>","created":"57 minutes ago","margin":"160","user":"cathustler"},{"id":"5337151","content":"<span class=\\"comment\\"><font color=\\"#000000\\">NekoTsui supports to change consumer key\\/secret.<a href=\\"https:\\/\\/itunes.apple.com\\/app\\/nekotsui\\/id476924886\\" rel=\\"nofollow\\">https:\\/\\/itunes.apple.com\\/app\\/nekotsui\\/id476924886<\\/a><\\/font><\\/span>","created":"2 hours ago","margin":"120","user":"matsuu"},{"id":"5337279","content":"<span class=\\"comment\\"><font color=\\"#000000\\">On Android, the foss client Twidere let users change the tokens in the options. <a href=\\"https:\\/\\/play.google.com\\/store\\/apps\\/details?id=org.mariotaku.twidere\\" rel=\\"nofollow\\">https:\\/\\/play.google.com\\/store\\/apps\\/details?id=org.mariotaku....<\\/a><p>The Chrome app Hotot too. <a href=\\"https:\\/\\/chrome.google.com\\/webstore\\/detail\\/hotot\\/cnfkkfleeiooolklkgkmigodkmcopnji\\" rel=\\"nofollow\\">https:\\/\\/chrome.google.com\\/webstore\\/detail\\/hotot\\/cnfkkfleeioo...<\\/a><\\/p><\\/font><\\/span>","created":"1 hour ago","margin":"120","user":"mortalkastor"},{"id":"5337365","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Twitter did this to themselves. Without the limit, this information is worthless. It\'ll make sense for an app like Tweetro[1] to add custom token as a feature or easter egg.<p>1: <a href=\\"http:\\/\\/www.theverge.com\\/2012\\/11\\/11\\/3631108\\/tweetro-user-token-limit-api\\" rel=\\"nofollow\\">http:\\/\\/www.theverge.com\\/2012\\/11\\/11\\/3631108\\/tweetro-user-toke...<\\/a><\\/p><\\/font><\\/span>","created":"1 hour ago","margin":"120","user":"soemarko"},{"id":"5337139","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Isn\'t this actually a great thing since it enables developers to develop Twitter clients that aren\'t dependent on tokens and approval from Twitter?<\\/font><\\/span>","created":"2 hours ago","margin":"40","user":"kristofferR"},{"id":"5337155","content":"<span class=\\"comment\\"><font color=\\"#000000\\">You could only make an app that would explode if\\/when they decide to change keys<\\/font><\\/span>","created":"2 hours ago","margin":"80","user":"scorcher"},{"id":"5337180","content":"<span class=\\"comment\\"><font color=\\"#000000\\">The app could also just download the latest extracted keys from your server when it experiences an authentication failure.<\\/font><\\/span>","created":"2 hours ago","margin":"120","user":"mtrimpe"},{"id":"5337170","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Along with any official client that is slightly out of date. Twitter might be hesitant to alienate their users.<\\/font><\\/span>","created":"2 hours ago","margin":"120","user":"Drakim"},{"id":"5337173","content":"<span class=\\"comment\\"><font color=\\"#000000\\">I guess twitter, and any other client would just say - key revoked, you need to update the app for it to work again. It\'s an endless game of cat and mouse.<\\/font><\\/span>","created":"2 hours ago","margin":"120","user":"aidos"},{"id":"5337323","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Using the official key in an unofficial client sounds like a problem that will be solved with the legal system, not by increasing the burden on Twitter.<\\/font><\\/span>","created":"1 hour ago","margin":"160","user":"nanidin"},{"id":"5337166","content":"<span class=\\"comment\\"><font color=\\"#000000\\">But they can\'t change those keys without isolating every installation until it\'s updated, right?<\\/font><\\/span>","created":"2 hours ago","margin":"120","user":"slig"},{"id":"5337391","content":"<span class=\\"comment\\"><font color=\\"#000000\\">Indeed. Constantly changing keys would cause as many problems for users of the official client as it would for unofficial clients.<p>Twitter could make some way for the official client to fetch new keys from a server without a binary update, but then they\'d have to somehow protect <i>that<\\/i> mechanism from third parties...<\\/p><p>I suppose the next logical step would be to procedurally generate keys based on the date, and have only the algorithm (not the keys themselves) known to the official client. Not in any way insurmountable, but a little more difficult to crack.<\\/p><\\/font><\\/span>","created":"1 hour ago","margin":"160","user":"dmdeller"}]')

$('.minimizer').click(didClickMinimizer);

});